# file opened: C:\Users\luisx\OneDrive - UFV\curso2\AOC\ejerYpruebas\L34-Parte1\main.asm
  1   0000              ; main.asm - Programa principal Conecta 4 (ZX Spectrum)
  2   0000              ; Inicialización, bucle principal, gestión de jugadas y subrutinas auxiliares
  3   0000
  4   0000                  DEVICE ZXSPECTRUM48
  5   0000                  ORG $8000
  6   8000 31 00 00         LD SP, 0
  7   8003 3E 00            LD A, 0 ; Valor inicial de A
  8   8005 D3 FE            OUT ($FE), A ; Colorea el marco de la pantalla en negro
  9   8007 C3 55 C0         JP INICIO
 10   800A
 11   800A              ; INCLUDES - módulos y rutinas auxiliares
 12   800A                  INCLUDE "colors.asm"         ; Definiciones de colores y jugadores
# file opened: C:\Users\luisx\OneDrive - UFV\curso2\AOC\ejerYpruebas\L34-Parte1\colors.asm
  1+  800A              ; CONSTANTES DE COLORES
  2+  800A              ; Valores de atributos de color (ej.: usado para imprimir texto en pantalla)
  3+  800A              COLOR_TEXTO_AZUL     EQU 1    ; Color azul (atributo de color 1)
  4+  800A              COLOR_TEXTO_ROJO     EQU 2    ; Color rojo  (atributo de color 2)
  5+  800A              COLOR_TEXTO_AMARILLO EQU 6   ; Color amarillo (atributo de color 6)
  6+  800A              BLINK                EQU 128  ; Bit de parpadeo (MSB del atributo). Combinar con OR: BLINK | color
  7+  800A              ; COLORES DISPONIBLES
  8+  800A              NEGRO               EQU 0    ; Color negro / fondo (valor 0)
  9+  800A              AZUL                EQU 1
 10+  800A              ; DISPONIBLES PARA JUGADORES, EL AZUL Y EL NEGRO DEBEN QUEDAR RESERVADOS PARA EL TABLERO
 11+  800A              COLOR_ROJO                EQU 2
 12+  800A              COLOR_MAGENTA             EQU 3
 13+  800A              COLOR_VERDE               EQU 4
 14+  800A              COLOR_CELESTE             EQU 5
 15+  800A              COLOR_AMARILLO            EQU 6
 16+  800A              COLOR_BLANCO              EQU 7
 17+  800A
 18+  800A              COLOR_NEGRO_FONDO_GANADOR EQU 0
# file closed: C:\Users\luisx\OneDrive - UFV\curso2\AOC\ejerYpruebas\L34-Parte1\colors.asm
 13   800A                  INCLUDE "variables.asm"      ; Variables globales y estado del juego
# file opened: C:\Users\luisx\OneDrive - UFV\curso2\AOC\ejerYpruebas\L34-Parte1\variables.asm
  1+  800A 18 FE        VARIABLES: JR VARIABLES
  2+  800C              ; variables.asm - Definición de constantes globales para el juego
  3+  800C              JUGADOR1 EQU 1
  4+  800C              JUGADOR2 EQU 2
  5+  800C              ; TOCA AQUI PARA MODIFICAR EL COLOR DE CUALQUIERA DE LOS DOS JUGADORES
  6+  800C              ; NOTA, UTILIZAR EL COLOR AZUL O EL NEGRO RESULTARÁ EN QUE NO SE NOTEN
  7+  800C              ; DIFERENCIAS ENTRE LAS FICHAS Y EL FONDO O LOS BORDES DEL TABLERO
  8+  800C              COLOR_JUGADOR1 EQU COLOR_CELESTE
  9+  800C              COLOR_JUGADOR2 EQU COLOR_MAGENTA
 10+  800C              ; DEFINICION DEL JUGADOR ACTUAL Y SU COLOR
 11+  800C 02           JUGADOR_ACTUAL: DB JUGADOR2
 12+  800D 03           COLOR_JUGADOR_ACTUAL: DB COLOR_JUGADOR2
 13+  800E 00           GANADOR: DB 0 ; CUANDO SE ENCUENTRE UN GANADOR, REALIZAR-- LD A, (COLOR_JUGADOR_ACTUAL): LD (GANADOR), A
 14+  800F              ; CONTADOR: valor usado para temporización en rutinas de espera (delay)
 15+  800F              CONTADOR EQU $0625
 16+  800F              ; NUM_FILAS: número total de filas en la pantalla (útil para posicionamiento y bucles)
 17+  800F              NUM_FILAS EQU 24
 18+  800F              ; NUM_COLS: número total de columnas en la pantalla (útil para posicionamiento y bucles)
 19+  800F              NUM_COLS EQU 32
 20+  800F              ; DIMENSIONES DEL TABLERO
 21+  800F              FILAS_TABLERO EQU 6
 22+  800F              COLUMNAS_TABLERO EQU 7
 23+  800F              ; DIMENSIONES DE DESPLAZAMIENTO POR EL TABLERO EN DB
 24+  800F              COLUMN_BOARD_SIZE EQU 7 ; DESPLAZAMIENTO QUE SE DEBE HACER PARA MOVERSE POR COLUMNAS EN EL TABLERO DE DB
 25+  800F              ROW_BOARD_SIZE    EQU 1 ; DESPLAZAMIENTO QUE SE DEBE HACER PARA MOVERSE POR FILAS EN EL TABLERO DE DB
 26+  800F              ; CONTADORES DE CONSECUTIVOS
 27+  800F 00           LEFT_COUNTER: DB 0
 28+  8010 00           RIGHT_COUNTER: DB 0
 29+  8011              ; TABLERO EN DB
 30+  8011 FF FF FF FF  TOP_BORDER:     DB $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
 30+  8015 FF FF FF FF
 31+  8019 00 00 00 00  TABLERO_ACTUAL: DB 0,0,0,0,0,0, $FF ; 00 10 20 30 40 50 (TOP LEFT CORNER TO BOTTOM LEFT CORNER)
 31+  801D 00 00 FF
 32+  8020 00 00 00 00                  DB 0,0,0,0,0,0, $FF ; 01 11 21 31 41 51
 32+  8024 00 00 FF
 33+  8027 00 00 00 00                  DB 0,0,0,0,0,0, $FF ; 02 12 22 32 42 52
 33+  802B 00 00 FF
 34+  802E 00 00 00 00                  DB 0,0,0,0,0,0, $FF ; 03 13 23 33 43 53
 34+  8032 00 00 FF
 35+  8035 00 00 00 00                  DB 0,0,0,0,0,0, $FF ; 04 14 24 34 44 54
 35+  8039 00 00 FF
 36+  803C 00 00 00 00                  DB 0,0,0,0,0,0, $FF ; 05 15 25 35 45 55
 36+  8040 00 00 FF
 37+  8043 00 00 00 00                  DB 0,0,0,0,0,0, $FF ; 06 16 26 36 46 56 (TOP RIGHT CORNER TO BOTTOM RIGHT CORNER)
 37+  8047 00 00 FF
 38+  804A FF FF FF FF                  DB $FF, $FF, $FF, $FF, $FF, $FF, $FF
 38+  804E FF FF FF
 39+  8051
# file closed: C:\Users\luisx\OneDrive - UFV\curso2\AOC\ejerYpruebas\L34-Parte1\variables.asm
 14   8051                  INCLUDE "keyboard.asm"       ; Rutinas de lectura de teclado
# file opened: C:\Users\luisx\OneDrive - UFV\curso2\AOC\ejerYpruebas\L34-Parte1\keyboard.asm
  1+  8051              ; keyboard.asm - rutinas de lectura de teclado
  2+  8051              ; Convención general:
  3+  8051              ;  - El puerto de teclado se accede con IN A,(C) usando C=$FE (puerto 0xFE típico de ZX Spectrum)
  4+  8051              ;  - El código prueba bits concretos del registro A (BIT n, A). Si el bit es 0 => tecla pulsada
  5+  8051              ;  - Después de detectar una pulsación, las rutinas esperan a la liberación de la tecla
  6+  8051              ;    haciendo bucles que leen IN A,(C) y comparan (A AND $1F) con $1F (estado sin teclas).
  7+  8051
  8+  8051              K_SON: ; LECTURA DE TECLADO PARA 'S' O 'N' (respuesta S/N)
  9+  8051 0E FE            LD C, $FE            ; puerto de lectura del teclado
 10+  8053
 11+  8053              ; KSON_BUCLE
 12+  8053              ; - Bucle que escanea el teclado hasta detectar S o N
 13+  8053              KSON_BUCLE:
 14+  8053 06 FD            LD B, $FD            ; (valor de fila / máscara usada en el esquema de teclado)
 15+  8055 ED 78            IN A, (C)            ; leer estado de las líneas del teclado
 16+  8057 CB 4F            BIT 1, A             ; prueba el bit 1 -> si Z (bit=0) la tecla correspondiente está pulsada
 17+  8059 28 0E            JR Z, KSON_S
 18+  805B
 19+  805B 06 7F            LD B, $7F            ; cambiar máscara/fila para comprobar la otra tecla
 20+  805D ED 78            IN A, (C)
 21+  805F CB 5F            BIT 3, A             ; prueba el bit 3 -> si Z la tecla 'N' está pulsada
 22+  8061 28 02            JR Z, KSON_N
 23+  8063
 24+  8063 20 EE            JR NZ, KSON_BUCLE    ; si ninguna detectada, repetir
 25+  8065
 26+  8065              KSON_N:
 27+  8065 16 4E            LD D, 'N'            ; devuelve en D el carácter 'N' si se detectó esa tecla
 28+  8067 18 02            JR KSON_RELEASE
 29+  8069
 30+  8069              KSON_S:
 31+  8069 16 53            LD D, 'S'            ; devuelve en D el carácter 'S' si se detectó esa tecla
 32+  806B
 33+  806B              ; KSON_RELEASE
 34+  806B              ; - Espera a que la tecla no este pulsada antes de retornar (anti-rebotes/simple debounce)
 35+  806B              KSON_RELEASE:
 36+  806B ED 78            IN A, (C)
 37+  806D E6 1F            AND $1F
 38+  806F FE 1F            CP $1F
 39+  8071 20 F8            JR NZ, KSON_RELEASE
 40+  8073
 41+  8073 C9               RET ; FIN DE KSON (D contiene 'S' o 'N')
 42+  8074
 43+  8074              ; K_LR_E_F
 44+  8074              ; - Rutina de lectura de teclado para las teclas Q (LEFT), W (RIGHT), ENTER (soltar ficha) o F
 45+  8074              K_LR_E_F:
 46+  8074 0E FE            LD C, $FE            ; puerto de lectura
 47+  8076 F5               PUSH AF
 48+  8077
 49+  8077              ; KLREF_BUCLE
 50+  8077              ; - Bucle que lee el teclado hasta detectar una de las teclas Q, W, ENTER o F con el uso de los bits
 51+  8077              ; - Esta rutina es para el jugador 1
 52+  8077              KLREF_BUCLE:
 53+  8077 3A 0C 80         LD A, (JUGADOR_ACTUAL)
 54+  807A FE 02            CP 2
 55+  807C 28 1A            JR Z, KLREF_BUCLE_J2
 56+  807E 06 FB            LD B, $FB            ; seleccionar/activar fila de teclado
 57+  8080 ED 78            IN A, (C)
 58+  8082 CB 47            BIT 0, A             ; si bit0 = 0 -> tecla Q
 59+  8084 28 4A            JR Z, KLREF_Q
 60+  8086 CB 4F            BIT 1, A             ; si bit1 = 0 -> tecla W
 61+  8088 28 42            JR Z, KLREF_W
 62+  808A CB 57            BIT 2, A
 63+  808C 28 3A            JR Z, KLREF_E
 64+  808E
 65+  808E 06 FD            LD B, $FD            ; otra fila para F
 66+  8090 ED 78            IN A, (C)
 67+  8092 CB 5F            BIT 3, A             ; si bit3 = 0 -> tecla F
 68+  8094 28 48            JR Z, KLREF_F
 69+  8096
 70+  8096 18 DF            JR KLREF_BUCLE       ; repetir hasta detectar una tecla
 71+  8098
 72+  8098              ; KLREF_BUCLE_J2
 73+  8098              ; - Bucle que lee el teclado hasta detectar una de las teclas O, P, ENTER o F
 74+  8098              ; - Esta rutina es para el jugador 2
 75+  8098              KLREF_BUCLE_J2:
 76+  8098 06 DF            LD B, $DF            ; seleccionar/activar fila de teclado
 77+  809A ED 78            IN A, (C)
 78+  809C CB 47            BIT 0, A             ; si bit0 = 0 -> tecla P
 79+  809E 28 12            JR Z, KLREF_P
 80+  80A0 CB 4F            BIT 1, A             ; si bit1 = 0 -> tecla O
 81+  80A2 28 12            JR Z, KLREF_O
 82+  80A4 CB 57            BIT 2, A
 83+  80A6 28 12            JR Z, KLREF_I
 84+  80A8
 85+  80A8 06 FD            LD B, $FD            ; otra fila para F
 86+  80AA ED 78            IN A, (C)
 87+  80AC CB 5F            BIT 3, A             ; si bit3 = 0 -> tecla F
 88+  80AE 28 2E            JR Z, KLREF_F
 89+  80B0
 90+  80B0 18 E6            JR KLREF_BUCLE_J2       ; repetir hasta detectar una tecla
 91+  80B2
 92+  80B2              KLREF_P:
 93+  80B2 16 50            LD D, 'P'   ; devuelve en D el carácter 'P' si se detectó esa tecla
 94+  80B4 18 06            JR KLREF_RELEASE_IOP
 95+  80B6
 96+  80B6              KLREF_O:
 97+  80B6 16 4F            LD D, 'O'   ; devuelve en D el carácter 'O' si se detectó esa tecla
 98+  80B8 18 02            JR KLREF_RELEASE_IOP
 99+  80BA
100+  80BA              KLREF_I:
101+  80BA 16 49            LD D, 'I'   ; devuelve en D el carácter 'I' si se detectó esa tecla
102+  80BC
103+  80BC              ; KLREF_RELEASE_IOP
104+  80BC              ; - Espera a que la tecla P u O no este pulsada antes de retornar (anti-rebotes/simple debounce)
105+  80BC              KLREF_RELEASE_IOP:
106+  80BC 06 DF            LD B, $DF
107+  80BE ED 78            IN A, (C)
108+  80C0 E6 1F            AND $1F
109+  80C2 FE 1F            CP $1F
110+  80C4 20 F6            JR NZ, KLREF_RELEASE_IOP
111+  80C6 F1               POP AF
112+  80C7 C9               RET
113+  80C8
114+  80C8              KLREF_E:
115+  80C8 16 45            LD D, 'E'            ; devuelve 'E' en D
116+  80CA 18 06            JR KLREF_RELEASE_QWE
117+  80CC
118+  80CC              KLREF_W:
119+  80CC 16 57            LD D, 'W'            ; devuelve 'W' en D
120+  80CE 18 02            JR KLREF_RELEASE_QWE
121+  80D0
122+  80D0              KLREF_Q:
123+  80D0 16 51            LD D, 'Q'            ; devuelve 'Q' en D
124+  80D2
125+  80D2              ; KLREF_RELEASE_QWE
126+  80D2              ; - Espera a que la tecla Q o W no este pulsada antes de retornar (anti-rebotes/simple debounce)
127+  80D2              KLREF_RELEASE_QWE:
128+  80D2 06 FB            LD B, $FB
129+  80D4 ED 78            IN A, (C)
130+  80D6 E6 1F            AND $1F
131+  80D8 FE 1F            CP $1F
132+  80DA 20 F6            JR NZ, KLREF_RELEASE_QWE
133+  80DC F1               POP AF
134+  80DD C9               RET
135+  80DE
136+  80DE              KLREF_F:
137+  80DE 16 46            LD D, 'F'            ; devuelve 'F' en D
138+  80E0
139+  80E0              ; KLREF_RELEASE_F
140+  80E0              ; - Espera a la liberación de la tecla F
141+  80E0              KLREF_RELEASE_F:
142+  80E0 06 FD            LD B, $FD
143+  80E2 ED 78            IN A, (C)
144+  80E4 E6 1F            AND $1F
145+  80E6 FE 1F            CP $1F
146+  80E8 20 F6            JR NZ, KLREF_RELEASE_F
147+  80EA F1               POP AF
148+  80EB C9               RET
# file closed: C:\Users\luisx\OneDrive - UFV\curso2\AOC\ejerYpruebas\L34-Parte1\keyboard.asm
 15   80EC                  INCLUDE "printat.asm"        ; Rutina de impresión en pantalla
# file opened: C:\Users\luisx\OneDrive - UFV\curso2\AOC\ejerYpruebas\L34-Parte1\printat.asm
  1+  80EC              ; -------------------------------
  2+  80EC              ; ZX Spectrum Text print library
  3+  80EC              ; Daniel León - AOC - UFV 2020
  4+  80EC              ; -------------------------------
  5+  80EC
  6+  80EC
  7+  80EC              ; ----------------------------------------------------------------------------------------
  8+  80EC              ; PRINTAT - Print a string in a position and attributes as per registers:
  9+  80EC              ;		IN	A	: Bit 7=1 For Flash / Bit 6=1 For Brigh / Bit 5,4,3 for Paper / Bit 2,1,0 for Ink
 10+  80EC              ;		IN	B	: Row 0..23
 11+  80EC              ;		IN	C	: Column 0..31
 12+  80EC              ;		IN	IX	: Address of text (Text must end in a 0)
 13+  80EC              ; ----------------------------------------------------------------------------------------
 14+  80EC CD FB 80     PRINTAT:	CALL PREP_PRT				; Update Attribute var &Screen & Attributes pointers
 15+  80EF              ; ----------------------------------------------------------------------------------------
 16+  80EF              ;		VVV Do not move PRINTSTR below as PRINTAT continues into PRINTSTR routine
 17+  80EF              ; ----------------------------------------------------------------------------------------
 18+  80EF              ; PRINTSTR - Prints String - IX Points to the String start
 19+  80EF              ; ----------------------------------------------------------------------------------------
 20+  80EF DD 7E 00     PRINTSTR:   LD A,(IX)					; A Contains first char to print
 21+  80F2 B7           			OR A						; check for end of string (0)
 22+  80F3 C8           			RET Z						; Finish printing if 0
 23+  80F4 CD 29 81     			CALL PRINTCHNUM
 24+  80F7 DD 23        			INC IX						; Move to next char in string
 25+  80F9 18 F4        			JR PRINTSTR					; Start over printing sequence
 26+  80FB              ; ----------------------------------------------------------------------------------------
 27+  80FB
 28+  80FB
 29+  80FB              ;-----------------------------------------------------------------------------------------
 30+  80FB              ; PREP_PRT - Updates Print_Attr, SCR & ATTR Vars
 31+  80FB              ;-----------------------------------------------------------------------------------------
 32+  80FB 32 6F 81     PREP_PRT:	LD (PRINT_ATTR),A			; Set Attribute
 33+  80FE CD 04 81     PREP_PRT_2:	CALL CRtoSCREEN
 34+  8101 C3 16 81     			JP CRtoATTR
 35+  8104              ;-----------------------------------------------------------------------------------------
 36+  8104
 37+  8104              ;-----------------------------------------------------------------------------------------
 38+  8104              ; CRtoSCREEN - Converts a scr char coord into a SCREEN Address   b,c = y,x positions
 39+  8104              ;	IN  - B=Row, C=Column
 40+  8104              ;	OUT - HL=Address in screen also stored in (SCR_CUR_PTR)
 41+  8104              ;	Conversion:
 42+  8104              ;			Row FFfff   Column CCCCC
 43+  8104              ;			HL=%010FF000 fffCCCCC
 44+  8104              ;-----------------------------------------------------------------------------------------
 45+  8104              CRtoSCREEN:
 46+  8104 78           			LD A,B						; %___FFfff
 47+  8105 F6 40        			OR #40						; %010FFfff
 48+  8107 E6 F8        			AND #F8						; %010FF000
 49+  8109 67           			LD H,A
 50+  810A
 51+  810A 78           			LD A,B						; %___FFfff
 52+  810B E6 07        			AND #7						; %00000fff
 53+  810D 0F           			RRCA						; %f00000ff
 54+  810E 0F           			RRCA						; %ff00000f
 55+  810F 0F           			RRCA						; %fff00000
 56+  8110 B1           			OR C						; %fffCCCCC
 57+  8111 6F           			LD L,A
 58+  8112 22 6B 81                 LD (SCR_CUR_PTR),HL			; Update Variable
 59+  8115 C9                       RET
 60+  8116              ; ----------------------------------------------------------------------------------------
 61+  8116
 62+  8116
 63+  8116
 64+  8116              ;-----------------------------------------------------------------------------------------
 65+  8116              ; CRtoATTR - Converts a screen char coord  into a ATTR Address  b,c = y,x positions
 66+  8116              ;	IN  - B=Row, C=Column
 67+  8116              ;	OUT - HL=Address in screen also stored in (SCR_ATTR_PTR)
 68+  8116              ;	Conversion:
 69+  8116              ;			Row FFfff   Column CCCCC
 70+  8116              ;			HL=%010110FF fffCCCCC
 71+  8116              ;-----------------------------------------------------------------------------------------
 72+  8116              CRtoATTR:
 73+  8116 78           			LD A,B						; %___FFfff
 74+  8117 0F           			RRCA						; %f000FFff
 75+  8118 0F           			RRCA						; %ff000FFf
 76+  8119 0F           			RRCA						; %fff000FF
 77+  811A 6F           			LD L,A
 78+  811B E6 03        			AND 3						; %000000FF	value of FF can be only 00,01,10
 79+  811D F6 58        			OR #58						; %010110FF value will be #58, #59 or #5A
 80+  811F 67           			LD H,A
 81+  8120
 82+  8120 7D           			LD A,L						; %fff000FF
 83+  8121 E6 E0        			AND #E0						; %fff00000
 84+  8123 B1           			OR C						; %fffCCCCC
 85+  8124 6F           			LD L,A
 86+  8125
 87+  8125 22 6D 81                 LD (SCR_ATTR_PTR),HL		; Update Variable
 88+  8128 C9                       RET
 89+  8129              ; ----------------------------------------------------------------------------------------
 90+  8129
 91+  8129
 92+  8129
 93+  8129              ; ----------------------------------------------------------------------------------------
 94+  8129              ; PRINTCHNUM - Prints Char Number N (stored in A)
 95+  8129              ;-----------------------------------------------------------------------------------------
 96+  8129              PRINTCHNUM:	;SUB 32						; Adjust Ascii to charset
 97+  8129 26 00        			LD H,0						; Multiply value by 8 to get to right Char in Charset
 98+  812B 6F           			LD L,A
 99+  812C 29           			ADD HL,HL
100+  812D 29           			ADD HL,HL
101+  812E 29           			ADD HL,HL
102+  812F 11 70 80     			LD DE, CHARSET-(8*32)		; Optimize in compile time (instead of sub 32)
103+  8132 19           			ADD HL,DE
104+  8133 EB           			EX  DE,HL					;Value in DE
105+  8134              			; Continues to printchar below
106+  8134              ; ----------------------------------------------------------------------------------------
107+  8134
108+  8134
109+  8134              ; ----------------------------------------------------------------------------------------
110+  8134              ; PRINTCHAR - Prints Char  (DE points to the char. Uses HL as last Cur Pointer)
111+  8134              ; ----------------------------------------------------------------------------------------
112+  8134              PRINTCHAR:
113+  8134 06 08        			LD B,8						; 8 Lines per char
114+  8136 2A 6B 81                 LD HL, (SCR_CUR_PTR)		; Load Cursor Pointer y,x
115+  8139
116+  8139 1A           BYTEPCHAR:	LD A,(DE)					; Get Char to be printed, first line
117+  813A 77           			LD (HL),A					; Move to Printing location
118+  813B 24                       INC H						; inc H so next line in char (ZX Spectrum Screen RAM)
119+  813C 13                       INC DE 						; next line to be printed
120+  813D 10 FA                    DJNZ BYTEPCHAR				; Repeat 8 lines
121+  813F 3A 6F 81                 LD A,(PRINT_ATTR) 			; Load Attributes to print char with
122+  8142 2A 6D 81                 LD HL, (SCR_ATTR_PTR)
123+  8145 77                       LD (HL),A
124+  8146 21 6D 81                 LD HL, SCR_ATTR_PTR			; Get pointer to ATTR
125+  8149 34                       INC (HL)					; Move Attribute cursor to next char
126+  814A 21 6B 81     			LD HL, SCR_CUR_PTR
127+  814D 34           			INC (HL)					; update Cursor pointer to next position
128+  814E C9                       RET
129+  814F              ; ----------------------------------------------------------------------------------------
130+  814F
131+  814F
132+  814F
133+  814F              ; ----------------------------------------------------------------------------------------
134+  814F              ; INK2PAPER - moves ink of attribute stored in (PRINT_ATTR) to paper and sets ink to 0
135+  814F              ; 				Sets bright 1 and flash 0
136+  814F              ; ----------------------------------------------------------------------------------------
137+  814F 3A 6F 81     INK2PAPER:	LD A, (PRINT_ATTR)		    ; Get storedAttribute
138+  8152 E6 07                    AND 7						; get Attr INK in A
139+  8154 07           			RLCA
140+  8155 07           			RLCA
141+  8156 07           			RLCA						; move Ink to Paper
142+  8157 F6 40        			OR 64						; ink 0 bright 1
143+  8159 32 6F 81     			LD (PRINT_ATTR),A		    ; Get storedAttribute
144+  815C C9           			RET
145+  815D              ; ----------------------------------------------------------------------------------------
146+  815D
147+  815D
148+  815D
149+  815D
150+  815D 21 00 40     CLEARSCR:	LD HL,$4000					; Erases screen by writing 0 to all pixels and attributes
151+  8160 11 01 40     			LD DE,$4001
152+  8163 01 FF 1A     			LD BC,6911
153+  8166 36 00        			LD (HL),0
154+  8168 ED B0        			LDIR
155+  816A C9           			RET
156+  816B
157+  816B
158+  816B              SCR_CUR_PTR
158+  816B 00 00          	db $00, $00				; Cursor Pointer in Screen (2 bytes) (HL)
159+  816D 00 00        SCR_ATTR_PTR: 	db $00, $00				; Attr Pointer in Screen (2 bytes) (HL)
160+  816F 00           PRINT_ATTR:		db $00					; Attribute used by printchar routine (1 byte)
161+  8170
162+  8170              CHARSET: incbin "charset.bin"			; Charset used
163+  8470
# file closed: C:\Users\luisx\OneDrive - UFV\curso2\AOC\ejerYpruebas\L34-Parte1\printat.asm
 16   8470                  INCLUDE "graphics_basic.asm" ; Rutinas gráficas básicas
# file opened: C:\Users\luisx\OneDrive - UFV\curso2\AOC\ejerYpruebas\L34-Parte1\graphics_basic.asm
  1+  8470              ; STRINGS PARA IMPRESION
  2+  8470
  3+  8470 20 20 20 20  STRING_FILA_VACIA_B: DB "                        ", 0    ; fila vacía (ancho para portada)
  3+  8474 20 20 20 20
  3+  8478 20 20 20 20
  3+  847C 20 20 20 20
  3+  8480 20 20 20 20
  3+  8484 20 20 20 20
  3+  8488 00
  4+  8489 20 42 69 65  STRING_BIENVENIDA: DB " Bienvenido a Conecta 4 ", 0    ; texto principal de bienvenida
  4+  848D 6E 76 65 6E
  4+  8491 69 64 6F 20
  4+  8495 61 20 43 6F
  4+  8499 6E 65 63 74
  4+  849D 61 20 34 20
  4+  84A1 00
  5+  84A2 20 51 75 69  STRING_JUGAR: DB " Quieres jugar? S/N:   ", 0          ; pregunta para iniciar partida
  5+  84A6 65 72 65 73
  5+  84AA 20 6A 75 67
  5+  84AE 61 72 3F 20
  5+  84B2 53 2F 4E 3A
  5+  84B6 20 20 20 00
  6+  84BA 20 20 20 20  STRING_FILA_VACIA_J: DB "                       ", 0   ; otra fila vacía para espaciado
  6+  84BE 20 20 20 20
  6+  84C2 20 20 20 20
  6+  84C6 20 20 20 20
  6+  84CA 20 20 20 20
  6+  84CE 20 20 20 00
  7+  84D2 20 20 20 20  STRING_FILA_VACIA_A: DB "            ", 0           ; fila vacía (alineación en pantalla)
  7+  84D6 20 20 20 20
  7+  84DA 20 20 20 20
  7+  84DE 00
  8+  84DF 20 20 41 44  STRING_ADIOS: DB "  ADIOS!!!! ", 0                 ; mensaje de despedida
  8+  84E3 49 4F 53 21
  8+  84E7 21 21 21 20
  8+  84EB 00
  9+  84EC 20 48 41 4E  STRING_EMPATE: DB " HAN EMPATADO ", 0     ; mensaje cuando termina la partida
  9+  84F0 20 45 4D 50
  9+  84F4 41 54 41 44
  9+  84F8 4F 20 00
 10+  84FB 20 20 20 20  STRING_FILA_VACIA_E: DB "              ", 0
 10+  84FF 20 20 20 20
 10+  8503 20 20 20 20
 10+  8507 20 20 00
 11+  850A 20 51 55 49  STRING_OTRA: DB " QUIEREN JUGAR OTRA VEZ? S/N:   ", 0 ; preguntar por otra partida
 11+  850E 45 52 45 4E
 11+  8512 20 4A 55 47
 11+  8516 41 52 20 4F
 11+  851A 54 52 41 20
 11+  851E 56 45 5A 3F
 11+  8522 20 53 2F 4E
 11+  8526 3A 20 20 20
 11+  852A 00
 12+  852B 51 3D 49 5A  STRING_CONTROLES_J1: DB "Q=IZQ, W=DER", 0
 12+  852F 51 2C 20 57
 12+  8533 3D 44 45 52
 12+  8537 00
 13+  8538 49 3D 49 5A  STRING_CONTROLES_J2: DB "I=IZQ, O=DER", 0
 13+  853C 51 2C 20 4F
 13+  8540 3D 44 45 52
 13+  8544 00
 14+  8545 42 41 4A 41  STRING_BAJAR: DB "BAJAR= / ", 0
 14+  8549 52 3D 20 2F
 14+  854D 20 00
 15+  854F 45 00        STRING_BJ1: DB "E", 0
 16+  8551 50 00        STRING_BJ2: DB "P", 0
 17+  8553 20 48 41 20  MENSAJE_VICTORIA: DB " HA GANADO EL JUGADOR ", 0
 17+  8557 47 41 4E 41
 17+  855B 44 4F 20 45
 17+  855F 4C 20 4A 55
 17+  8563 47 41 44 4F
 17+  8567 52 20 00
 18+  856A 20 20 20 20  NOMBRE_GANADOR: DB "           ", 0 ; 11 caracteres + 1 byte para el 0 = 12 bytes
 18+  856E 20 20 20 20
 18+  8572 20 20 20 00
 19+  8576 20 20 20 52                  DB "   ROJO    ", 0
 19+  857A 4F 4A 4F 20
 19+  857E 20 20 20 00
 20+  8582 20 20 4D 41                  DB "  MAGENTA  ", 0
 20+  8586 47 45 4E 54
 20+  858A 41 20 20 00
 21+  858E 20 20 20 56                  DB "   VERDE   ", 0
 21+  8592 45 52 44 45
 21+  8596 20 20 20 00
 22+  859A 20 20 43 45                  DB "  CELESTE  ", 0
 22+  859E 4C 45 53 54
 22+  85A2 45 20 20 00
 23+  85A6 20 41 4D 41                  DB " AMARILLO  ", 0
 23+  85AA 52 49 4C 4C
 23+  85AE 4F 20 20 00
 24+  85B2 20 20 42 4C                  DB "  BLANCO   ", 0
 24+  85B6 41 4E 43 4F
 24+  85BA 20 20 20 00
 25+  85BE 00 00        CHAR_CARACTER: DB 0, 0                               ; buffer de 1 byte para el caracter pulsado
 26+  85C0
 27+  85C0              ; PANTALLA DE INICIO
 28+  85C0              PANTALLA_BIENVENIDA: INCBIN "connect4screen.SCR" ; Pantalla inicial (portada) del juego
 29+  A0C0              PANTALLA_JUEGO: INCBIN "connect4gameScreen.scr" ; Pantalla del tablero en la partida
 30+  BBC0
 31+  BBC0              GB_BIENVENIDA:
 32+  BBC0                  ; Guardamos registros usados antes de manipular la pantalla
 33+  BBC0 D5               PUSH DE
 33+  BBC1 E5             PUSH HL
 33+  BBC2 C5             PUSH BC
 33+  BBC3 F5             PUSH AF
 34+  BBC4
 35+  BBC4                  ; Copia la imagen BIN a la VRAM/direccion de pantalla
 36+  BBC4 11 00 40         LD DE, $4000                 ; dirección destino en memoria de pantalla (ejemplo)
 37+  BBC7 21 C0 85         LD HL, PANTALLA_BIENVENIDA  ; dirección fuente (bin incluido)
 38+  BBCA 01 00 1B         LD BC, $5B00 - $4000        ; longitud en bytes a copiar
 39+  BBCD              BIENVENIDA_BUCLE:
 40+  BBCD ED B0            LDIR ; copia BC bytes desde (HL) a (DE) incrementando HL/DE
 41+  BBCF
 42+  BBCF              ; PRINT_BIENVENIDA: imprime texto y mensajes sobre la portada cargada
 43+  BBCF              ; Convención usada por PRINTAT (por contrato):
 44+  BBCF              ;   B = fila, C = columna, IX = puntero a cadena, A = atributo/color (opcional)
 45+  BBCF              PRINT_BIENVENIDA: ; IMPRIME EL MENSAJE DE BIENVENIDA
 46+  BBCF 06 01            LD B, 1
 47+  BBD1 0E 04            LD C, 4
 48+  BBD3 DD 21 70 84      LD IX, STRING_FILA_VACIA_B
 49+  BBD7 CD EC 80         CALL PRINTAT
 50+  BBDA 06 03            LD B, 3
 51+  BBDC DD 21 70 84      LD IX, STRING_FILA_VACIA_B
 52+  BBE0 CD EC 80         CALL PRINTAT
 53+  BBE3 06 02            LD B, 2
 54+  BBE5 3E 02            LD A, COLOR_TEXTO_ROJO         ; atributo de color para la línea central
 55+  BBE7 DD 21 89 84      LD IX, STRING_BIENVENIDA
 56+  BBEB CD EC 80         CALL PRINTAT
 57+  BBEE
 58+  BBEE                  ; Espaciado y pregunta para jugar
 59+  BBEE 06 14            LD B, 20
 60+  BBF0 0E 09            LD C, 9
 61+  BBF2 DD 21 BA 84      LD IX, STRING_FILA_VACIA_J
 62+  BBF6 CD EC 80         CALL PRINTAT
 63+  BBF9 06 16            LD B, 22
 64+  BBFB DD 21 BA 84      LD IX, STRING_FILA_VACIA_J
 65+  BBFF CD EC 80         CALL PRINTAT
 66+  BC02 06 15            LD B, 21
 67+  BC04 3E 06            LD A, COLOR_TEXTO_AMARILLO     ; color para la pregunta
 68+  BC06 DD 21 A2 84      LD IX, STRING_JUGAR ; IMPRIME EL MENSAJE PREGUNTANDO SI SE QUIERE JUGAR
 69+  BC0A CD EC 80         CALL PRINTAT
 70+  BC0D                  ; Preparamos el atributo para el blinker (parpadeo)
 71+  BC0D 3E B0            LD A, BLINK + 8*COLOR_TEXTO_AMARILLO ; BLINK combinado con un valor de color
 72+  BC0F
 73+  BC0F              ;
 74+  BC0F              GB_PRUEBA: ; Pinta en pantalla el atributo de parpadeo en la posición indicada
 75+  BC0F 06 15            LD B, 21
 76+  BC11 0E 1E            LD C, 30
 77+  BC13 21 BE 5A         LD HL, $5800 + 21*NUM_COLS + 30  ; dirección de la celda (fila*NUM_COLS + col) en buffer de pantalla
 78+  BC16 77               LD (HL), A                        ; escribe el atributo (parpadeo) directamente en VRAM
 79+  BC17 F1               POP AF
 79+  BC18 C1             POP BC
 79+  BC19 E1             POP HL
 79+  BC1A D1             POP DE    ; restaura registros y sale
 80+  BC1B
 81+  BC1B C9               RET
 82+  BC1C              ; GB_BLINKER_JUGAR BUENO
 83+  BC1C              GB_BLINKER_JUGAR:
 84+  BC1C 06 15            LD B, 21
 85+  BC1E 0E 1E            LD C, 30
 86+  BC20 21 BE 5A         LD HL, $5800 + 21*NUM_COLS + 30  ; dirección de la celda (fila*NUM_COLS + col) en buffer de pantalla
 87+  BC23 77               LD (HL), A
 88+  BC24 C9               RET
 89+  BC25
 90+  BC25              GB_PRINT_CHAR_SON: ; Imprime el caracter que escribió el usuario en la misma posición del blinker
 91+  BC25 06 15            LD B, 21
 92+  BC27 0E 1E            LD C, 30
 93+  BC29 DD 21 BE 85      LD IX, CHAR_CARACTER
 94+  BC2D CD EC 80         CALL PRINTAT
 95+  BC30
 96+  BC30 C9               RET
 97+  BC31
 98+  BC31              GB_ADIOS: ; Muestra la pantalla de despedida 'ADIOS' (uso similar a bienvenida)
 99+  BC31 CD 3E BD         CALL PTLLA_NEGRA    ; limpia la pantalla antes de escribir
100+  BC34              PRINT_ADIOS:
101+  BC34 06 0A            LD B, 10
102+  BC36 0E 0A            LD C, 10
103+  BC38 3E 10            LD A, 8*COLOR_TEXTO_ROJO    ; atributo/color para el texto de adiós
104+  BC3A DD 21 D2 84      LD IX, STRING_FILA_VACIA_A
105+  BC3E CD EC 80         CALL PRINTAT
106+  BC41 06 0C            LD B, 12
107+  BC43 3E 10            LD A, 8*COLOR_TEXTO_ROJO
108+  BC45 DD 21 D2 84      LD IX, STRING_FILA_VACIA_A
109+  BC49 CD EC 80         CALL PRINTAT
110+  BC4C 06 0B            LD B, 11
111+  BC4E 3E 10            LD A, 8*COLOR_TEXTO_ROJO
112+  BC50 DD 21 DF 84      LD IX, STRING_ADIOS
113+  BC54 CD EC 80         CALL PRINTAT
114+  BC57
115+  BC57 C9               RET
116+  BC58
117+  BC58              ; GB_FIN_NEXT
118+  BC58              ; Imprime la pantalla y mensajes de fin de la partida, incluyendo el ganador de la partida
119+  BC58              ; y si se desea jugar nuevamente o no
120+  BC58              GB_FIN_NEXT:
121+  BC58 D5               PUSH DE
121+  BC59 E5             PUSH HL
121+  BC5A C5             PUSH BC
121+  BC5B F5             PUSH AF
122+  BC5C CD 0D BD         CALL PRINT_GANADOR
123+  BC5F F1               POP AF
123+  BC60 C1             POP BC
123+  BC61 E1             POP HL
123+  BC62 D1             POP DE
124+  BC63 C9               RET
125+  BC64
126+  BC64              ; GB_EMPATE
127+  BC64              ; Imprime el mensaje informando que la partida ha finalizado en un empate, ya que el tablero
128+  BC64              ; se llenó sin que ningún jugador consiguiera 4 en raya
129+  BC64              GB_EMPATE:
130+  BC64 D5               PUSH DE
130+  BC65 E5             PUSH HL
130+  BC66 C5             PUSH BC
130+  BC67 F5             PUSH AF
131+  BC68 CD 3E BD         CALL PTLLA_NEGRA
132+  BC6B 06 0B            LD B, 11
133+  BC6D 0E 08            LD C, 8
134+  BC6F 3E 10            LD A, 8*COLOR_TEXTO_ROJO
135+  BC71 DD 21 FB 84      LD IX, STRING_FILA_VACIA_E
136+  BC75 CD EC 80         CALL PRINTAT
137+  BC78 06 0D            LD B, 13
138+  BC7A 0E 08            LD C, 8
139+  BC7C 3E 10            LD A, 8*COLOR_TEXTO_ROJO
140+  BC7E DD 21 FB 84      LD IX, STRING_FILA_VACIA_E
141+  BC82 CD EC 80         CALL PRINTAT
142+  BC85 06 0C            LD B, 12
143+  BC87 0E 08            LD C, 8
144+  BC89 3E 10            LD A, 8*COLOR_TEXTO_ROJO
145+  BC8B DD 21 EC 84      LD IX, STRING_EMPATE
146+  BC8F CD EC 80         CALL PRINTAT
147+  BC92 F1               POP AF
147+  BC93 C1             POP BC
147+  BC94 E1             POP HL
147+  BC95 D1             POP DE
148+  BC96 C9               RET
149+  BC97
150+  BC97              PRINT_FIN:
151+  BC97 06 0F            LD B, 15
152+  BC99 0E 03            LD C, 3
153+  BC9B 3E 10            LD A, 8*COLOR_TEXTO_ROJO
154+  BC9D DD 21 EC 84      LD IX, STRING_EMPATE
155+  BCA1 CD EC 80         CALL PRINTAT
156+  BCA4
157+  BCA4              ; Impresion del mensaje ofreciendo jugar otra partida
158+  BCA4              PRINT_OTRA:
159+  BCA4 06 15            LD B, 21
160+  BCA6 0E 00            LD C, 0
161+  BCA8 3E 10            LD A, 8*COLOR_TEXTO_ROJO
162+  BCAA DD 21 0A 85      LD IX, STRING_OTRA
163+  BCAE CD EC 80         CALL PRINTAT
164+  BCB1 3E 90            LD A, BLINK + 8*COLOR_TEXTO_ROJO
165+  BCB3 CD 1C BC         CALL GB_BLINKER_JUGAR
166+  BCB6 C9               RET
167+  BCB7
168+  BCB7              ; GB_PTLLA_INICIO_DE_JUEGO
169+  BCB7              ; Imprime la pantalla inicial del tablero con la cuadrícula de 6x7 y los círculos (de momento no visibles)
170+  BCB7              ; por encima del tablero.
171+  BCB7              GB_PTLLA_INICIO_DE_JUEGO:
172+  BCB7                  ; Inicializa la pantalla del juego (limpia y carga la plantilla de juego)
173+  BCB7 CD 3E BD         CALL PTLLA_NEGRA
174+  BCBA                  ; Guardamos registros usados antes de manipular la pantalla
175+  BCBA D5               PUSH DE
175+  BCBB E5             PUSH HL
175+  BCBC C5             PUSH BC
175+  BCBD F5             PUSH AF
176+  BCBE
177+  BCBE                  ; Copia la imagen BIN a la VRAM/direccion de pantalla
178+  BCBE 11 00 40         LD DE, $4000                 ; dirección destino en memoria de pantalla (ejemplo)
179+  BCC1 21 C0 A0         LD HL, PANTALLA_JUEGO  ; dirección fuente (bin incluido)
180+  BCC4 01 00 1B         LD BC, $5B00 - $4000        ; longitud en bytes a copiar
181+  BCC7              PTLLA_JUEGO_BUCLE:
182+  BCC7 ED B0            LDIR ; copia BC bytes desde (HL) a (DE) incrementando HL/DE
183+  BCC9
184+  BCC9 F1               POP AF
184+  BCCA C1             POP BC
184+  BCCB E1             POP HL
184+  BCCC D1             POP DE
185+  BCCD
186+  BCCD              ; Rutina que imprime los controles para cada jugador, en su respectivo color
187+  BCCD              PRINT_CONTROLES:
188+  BCCD 06 00            LD B, 0
189+  BCCF 0E 01            LD C, 1
190+  BCD1 3E 05            LD A, COLOR_JUGADOR1    ; atributo/color para el texto de adiós
191+  BCD3 DD 21 2B 85      LD IX, STRING_CONTROLES_J1
192+  BCD7 CD EC 80         CALL PRINTAT
193+  BCDA 0E 14            LD C, 20
194+  BCDC 3E 03            LD A, COLOR_JUGADOR2
195+  BCDE DD 21 38 85      LD IX, STRING_CONTROLES_J2
196+  BCE2 CD EC 80         CALL PRINTAT
197+  BCE5 06 17            LD B, 23
198+  BCE7 0E 0A            LD C, 10
199+  BCE9 3E 07            LD A, COLOR_BLANCO
200+  BCEB DD 21 45 85      LD IX, STRING_BAJAR
201+  BCEF CD EC 80         CALL PRINTAT
202+  BCF2 06 17            LD B, 23
203+  BCF4 0E 10            LD C, 16
204+  BCF6 3E 05            LD A, COLOR_JUGADOR1
205+  BCF8 DD 21 4F 85      LD IX, STRING_BJ1
206+  BCFC CD EC 80         CALL PRINTAT
207+  BCFF 06 17            LD B, 23
208+  BD01 0E 12            LD C, 18
209+  BD03 3E 03            LD A, COLOR_JUGADOR2
210+  BD05 DD 21 51 85      LD IX, STRING_BJ2
211+  BD09 CD EC 80         CALL PRINTAT
212+  BD0C C9               RET
213+  BD0D
214+  BD0D              ; Impresion del ganador, incluye mensaje general de victoria + el nombre del jugador ganador en su color.
215+  BD0D              PRINT_GANADOR:
216+  BD0D CD 54 BD         CALL GB_PRINT_FONDO_GANADOR
217+  BD10 06 0B            LD B, 11
218+  BD12 0E 04            LD C, 4
219+  BD14 3E 07            LD A, COLOR_BLANCO    ; atributo/color para el texto de adiós
220+  BD16 DD 21 53 85      LD IX, MENSAJE_VICTORIA
221+  BD1A CD EC 80         CALL PRINTAT
222+  BD1D 06 0C            LD B, 12    ; Fila donde saldra el nombre
223+  BD1F 0E 0A            LD C, 10    ; Columna
224+  BD21 C5               PUSH BC ; Guardamos coordenadas
225+  BD22 DD 21 6A 85      LD IX, NOMBRE_GANADOR
226+  BD26 3A 0E 80         LD A, (GANADOR)
226+  BD29 F5             PUSH AF    ; Guardamos color
227+  BD2A 47               LD B, A
227+  BD2B 05             DEC B
228+  BD2C 28 07            JR Z, IMPRIMIR_GANADOR
229+  BD2E 11 0C 00         LD DE, 12   ; Longitud 11 letras + 1 cero
230+  BD31              CONSEGUIR_GANADOR:
231+  BD31 DD 19            ADD IX, DE
232+  BD33 10 FC            DJNZ CONSEGUIR_GANADOR
233+  BD35              IMPRIMIR_GANADOR:
234+  BD35 F1               POP AF
234+  BD36 C1             POP BC  ; Recuperamos color y coordenadas
235+  BD37 CD EC 80         CALL PRINTAT
236+  BD3A CD A4 BC         CALL PRINT_OTRA ; Imprime el mensaje ofreciendo jugar otra partida
237+  BD3D C9               RET
238+  BD3E
239+  BD3E              PTLLA_NEGRA:
240+  BD3E                  ; Llena la pantalla con ceros (pantalla en negro)
241+  BD3E C5               PUSH BC
241+  BD3F D5             PUSH DE
241+  BD40 E5             PUSH HL
241+  BD41 F5             PUSH AF
242+  BD42
243+  BD42 21 00 58         LD   HL,$5800
244+  BD45 11 01 58         LD   DE,$5801
245+  BD48 36 00            LD   (HL),0
246+  BD4A 01 FF 02         LD   BC,768-1
247+  BD4D ED B0            LDIR    ; copia 768 bytes-1 para limpiar buffer de pantalla
248+  BD4F
249+  BD4F F1               POP AF
249+  BD50 E1             POP HL
249+  BD51 D1             POP DE
249+  BD52 C1             POP BC
250+  BD53 C9               RET
251+  BD54
252+  BD54              ; PARA LA PANTALLA DE GANADOR, AL DARLE A LA F
253+  BD54              GB_PRINT_FONDO_GANADOR:
254+  BD54 E5               PUSH HL
254+  BD55 C5             PUSH BC
254+  BD56 F5             PUSH AF
255+  BD57 21 00 58         LD HL, $5800
C:\Users\luisx\OneDrive - UFV\curso2\AOC\ejerYpruebas\L34-Parte1\graphics_basic.asm(256): error: Label not found: COLOR_BLANCO_FONDO_GANADOR
256+  BD5A 06 00            LD B, COLOR_BLANCO_FONDO_GANADOR
257+  BD5C              BUCLE_PTLLA:
258+  BD5C 70               LD (HL), B
259+  BD5D 23               INC HL
260+  BD5E 7C               LD A, H
261+  BD5F FE 5B            CP $5B
262+  BD61 20 F9            JR NZ, BUCLE_PTLLA
263+  BD63 F1               POP AF
263+  BD64 C1             POP BC
263+  BD65 E1             POP HL
264+  BD66 C9               RET
# file closed: C:\Users\luisx\OneDrive - UFV\curso2\AOC\ejerYpruebas\L34-Parte1\graphics_basic.asm
 17   BD67                  INCLUDE "graphics_core.asm"  ; Rutinas gráficas avanzadas
# file opened: C:\Users\luisx\OneDrive - UFV\curso2\AOC\ejerYpruebas\L34-Parte1\graphics_core.asm
  1+  BD67              ; GC_COLOR_JUGADOR_ACTUAL
  2+  BD67              ;  - Pone el atributo/color del jugador actual en un bloque 3x3
  3+  BD67              ;  - Convenios:
  4+  BD67              ;      D contiene el color base del jugador (ej. 2 o 6)
  5+  BD67              ;      BLINK es el bit de parpadeo; se añade para el efecto visual
  6+  BD67              ;      INC_HL_3X3 escribe/avanza sobre un bloque 3x3 usando (HL)
  7+  BD67              ;  - Efecto: carga A con D|BLINK y aplica ese atributo en la celda base $5845 (3 llamadas -> 3 filas del bloque)
  8+  BD67              GC_COLOR_JUGADOR_ACTUAL:
  9+  BD67 3A 0C 80         LD A, (JUGADOR_ACTUAL)
 10+  BD6A 21 00 00         LD HL, $00
 11+  BD6D FE 02            CP 2
 11+  BD6F CC 7B BD       CALL Z, SET_HL_J2
 12+  BD72 3A 0D 80         LD A, (COLOR_JUGADOR_ACTUAL)
 13+  BD75 C6 80            ADD BLINK
 14+  BD77 CD 7F BD         CALL GC_COLOR_CIRCLE
 15+  BD7A C9               RET
 16+  BD7B              ; El jugador 2 empieza en la columna 6 (Fila = 0, Columna = 6)
 17+  BD7B              SET_HL_J2
 18+  BD7B 21 06 00         LD HL, $06
 19+  BD7E C9               RET
 20+  BD7F
 21+  BD7F              ; RECIBE UNA DIRECCION HL DONDE H = FILA DEL TABLERO, L = COLUMNA DEL TABLERO Y COLOREA TODO EL CIRCULO,
 22+  BD7F              ; OJO, EN A RECIBE UNICAMENTE EL COLOR DEL INK A PINTAR, EL PAPER Y EL BRIGHT LO DEBE RESPETAR
 23+  BD7F              GC_COLOR_CIRCLE:
 24+  BD7F E5               PUSH HL
 24+  BD80 F5             PUSH AF
 24+  BD81 C5             PUSH BC
 24+  BD82 D5             PUSH DE
 25+  BD83 CD C0 BF         CALL LC_SLOT_POINTER ; HL = DIRECCION DE VIDEORAM DEL PAR FILA COLUMNA
 26+  BD86 01 1E 00         LD BC, $1E
 27+  BD89 57               LD D, A
 28+  BD8A 3E 78            LD A, %01111000
 28+  BD8C A6             AND (HL)
 28+  BD8D 82             ADD A, D
 29+  BD8E 77               LD (HL), A
 29+  BD8F 23             INC HL
 29+  BD90 77             LD (HL), A
 29+  BD91 23             INC HL
 29+  BD92 77             LD (HL), A
 29+  BD93 09             ADD HL, BC
 30+  BD94 77               LD (HL), A
 30+  BD95 23             INC HL
 30+  BD96 77             LD (HL), A
 30+  BD97 23             INC HL
 30+  BD98 77             LD (HL), A
 30+  BD99 09             ADD HL, BC
 31+  BD9A 77               LD (HL), A
 31+  BD9B 23             INC HL
 31+  BD9C 77             LD (HL), A
 31+  BD9D 23             INC HL
 31+  BD9E 77             LD (HL), A
 31+  BD9F 09             ADD HL, BC ; EL CIRCULO HA SIDO COLOREADO POR COMPLETO
 32+  BDA0 D1               POP DE
 32+  BDA1 C1             POP BC
 32+  BDA2 F1             POP AF
 32+  BDA3 E1             POP HL
 33+  BDA4
 34+  BDA4 C9               RET
 35+  BDA5
 36+  BDA5              ; GC_LEFT
 37+  BDA5              ;  - Borra (pone NEGRO) un bloque 3x3 en la posición actual apuntada por HL,
 38+  BDA5              ;    desplaza HL hacia la izquierda (restando 3) y vuelve a borrar el bloque
 39+  BDA5              ;  - Notas:
 40+  BDA5              ;    ADD HL, $FFFD es equivalente a HL -= 3 (0xFFFD = -3 en aritmética de 16 bits)
 41+  BDA5              ;    Se usan múltiples PUSH/POP para preservar registros y valores temporales
 42+  BDA5              GC_LEFT:
 43+  BDA5 F5               PUSH AF
 44+  BDA6 3E 00            LD A, NEGRO
 45+  BDA8 CD 7F BD         CALL GC_COLOR_CIRCLE
 46+  BDAB 2D               DEC L; HL VALE FILA,COLUMNA+1
 47+  BDAC 3A 0D 80         LD A, (COLOR_JUGADOR_ACTUAL)
 48+  BDAF C6 80            ADD BLINK
 49+  BDB1 CD 7F BD         CALL GC_COLOR_CIRCLE ; HL VALE FILA, COLUMNA + 1 AL FINALIZAR (RESPECTO A VALOR ORIGINAL)
 50+  BDB4 F1               POP AF
 51+  BDB5
 52+  BDB5 C9               RET
 53+  BDB6
 54+  BDB6              ; GC_RIGHT
 55+  BDB6              ;  - Simétrico a GC_LEFT: borra el bloque 3x3 actual, desplaza HL a la derecha (+3)
 56+  BDB6              ;    y borra el nuevo bloque. Usado para desplazar un cursor/selección a la derecha.
 57+  BDB6              ;  - ADD HL, 3 mueve la posición 3 bytes adelante (una columna/columna visual de 3)
 58+  BDB6              GC_RIGHT:
 59+  BDB6 F5               PUSH AF
 60+  BDB7 3E 00            LD A, NEGRO
 61+  BDB9 CD 7F BD         CALL GC_COLOR_CIRCLE
 62+  BDBC 2C               INC L; HL VALE FILA,COLUMNA+1
 63+  BDBD 3A 0D 80         LD A, (COLOR_JUGADOR_ACTUAL)
 64+  BDC0 C6 80            ADD BLINK
 65+  BDC2 CD 7F BD         CALL GC_COLOR_CIRCLE ; HL VALE FILA, COLUMNA + 1 AL FINALIZAR (RESPECTO A VALOR ORIGINAL)
 66+  BDC5 F1               POP AF
 67+  BDC6
 68+  BDC6 C9               RET
 69+  BDC7
 70+  BDC7              ; GC_ENTER
 71+  BDC7              ;   - Rutina que realiza los procesos gráficos tras pulsar para bajar una ficha en una determinada columna
 72+  BDC7              ;   - La rutina simula la caída de la ficha borrando, pintando, esperando y comprobando si puede volver a bajar.
 73+  BDC7              GC_ENTER:
 74+  BDC7 F5               PUSH AF
 75+  BDC8 C5               PUSH BC
 76+  BDC9 D5               PUSH DE
 77+  BDCA
 78+  BDCA              ; SOLTAR_FICHA_BUCLE
 79+  BDCA              ; - Rutina que simula la caída de una ficha en la columna seleccionada
 80+  BDCA              ; - INC H para moverse a la siguiente fila
 81+  BDCA              ; - Se hace una pausa para que se vea el movimiento
 82+  BDCA              SOLTAR_FICHA_BUCLE:
 83+  BDCA                  ; Borrar círculo actual
 84+  BDCA 3E 00            LD A, NEGRO
 85+  BDCC CD 7F BD         CALL GC_COLOR_CIRCLE
 86+  BDCF                  ; Pintarlo una fila más abajo
 87+  BDCF 24               INC H
 88+  BDD0 3A 0D 80         LD A, (COLOR_JUGADOR_ACTUAL)
 89+  BDD3 CD 7F BD         CALL GC_COLOR_CIRCLE
 90+  BDD6                  ; Esperar
 91+  BDD6 CD 47 C0         CALL U_ESPERAR
 92+  BDD9
 93+  BDD9                  ; Comprobar si se puede volver a pintar
 94+  BDD9 CD 36 C0         CALL U_CALC_TABLERO_POS      ; Devuelve IX en la posición (H,L) fila, columna actual.
 95+  BDDC                  ; Comprobar si la posición de abajo está libre
 96+  BDDC DD 7E 00         LD A, (IX)
 97+  BDDF B7               OR A
 98+  BDE0 20 02            JR NZ, FICHA_LANDED ; Si no es cero, la posición está ocupada y se tiene que bajar la ficha
 99+  BDE2 18 E6            JR SOLTAR_FICHA_BUCLE   ; Si es cero, se sigue bajando la ficha
100+  BDE4
101+  BDE4              ; FICHA_LANDED
102+  BDE4              ; - DEC H devuelve la coordenada a la ultima posicion vacia valida
103+  BDE4              ; - Con LD (IX), A se guarda la ficha del jugador actual en la "memoria del tablero"
104+  BDE4              FICHA_LANDED:
105+  BDE4                  ; Calculate correct TABLERO_ACTUAL position and save piece
106+  BDE4 25               DEC H
107+  BDE5 CD 36 C0         CALL U_CALC_TABLERO_POS      ; IX apunta a la posición actual en memoria
108+  BDE8 3A 0C 80         LD A, (JUGADOR_ACTUAL) ; 1 o 2, según el turno.
109+  BDEB DD 77 00         LD (IX), A ; Guarda que ese espacio está ocupado por el jugador que ha tirado
110+  BDEE
111+  BDEE D1               POP DE
111+  BDEF C1             POP BC
111+  BDF0 F1            POP AF
112+  BDF1 C9               RET
# file closed: C:\Users\luisx\OneDrive - UFV\curso2\AOC\ejerYpruebas\L34-Parte1\graphics_core.asm
 18   BDF2                  INCLUDE "logic_flow.asm"     ; Flujo principal del juego
# file opened: C:\Users\luisx\OneDrive - UFV\curso2\AOC\ejerYpruebas\L34-Parte1\logic_flow.asm
  1+  BDF2              ; logic_flow.asm - Rutinas de control de flujo principal del juego
  2+  BDF2
  3+  BDF2
  4+  BDF2
  5+  BDF2              ; LF_INICIALIZACION
  6+  BDF2              ;  - Inicializa el estado lógico y gráfico del juego (por ejemplo, dibuja la fila superior de círculos)
  7+  BDF2              ;  - D = PLAYER2 (jugador inicial por defecto)
  8+  BDF2              ;  - Llama a GC_DRAW_CIRCLES_TOP para preparar la pantalla
  9+  BDF2              LF_INICIALIZACION:
 10+  BDF2 F5               PUSH AF
 11+  BDF3 3A 0C 80         LD A, (JUGADOR_ACTUAL)
 12+  BDF6 57               LD D, A
 13+  BDF7 F1               POP AF
 14+  BDF8 CD 22 BE         CALL LF_BOARD_RESET
 15+  BDFB C9               RET
 16+  BDFC
 17+  BDFC              ; LF_SWITCH_JUGADOR
 18+  BDFC              ;  - Cambia el jugador actual (D) entre PLAYER1 y PLAYER2
 19+  BDFC              ;  - Si D = PLAYER2, lo cambia a PLAYER1; si D = PLAYER1, lo cambia a PLAYER2
 20+  BDFC              ;  - Usa saltos condicionales para seleccionar el nuevo valor
 21+  BDFC              LF_SWITCH_JUGADOR:
 22+  BDFC 3A 0C 80         LD A, (JUGADOR_ACTUAL)
 23+  BDFF FE 02            CP JUGADOR2
 24+  BE01 28 04            JR Z, SET_P1         ; si era PLAYER2, pasa a PLAYER1
 25+  BE03 FE 01            CP JUGADOR1
 26+  BE05 28 0E            JR Z, SET_P2         ; si era PLAYER1, pasa a PLAYER2
 27+  BE07              SET_P1:
 28+  BE07 F5               PUSH AF
 29+  BE08 3E 01            LD A, JUGADOR1
 30+  BE0A 32 0C 80         LD (JUGADOR_ACTUAL), A
 31+  BE0D 3E 05            LD A, COLOR_JUGADOR1
 32+  BE0F 32 0D 80         LD (COLOR_JUGADOR_ACTUAL), A
 33+  BE12 F1               POP AF
 34+  BE13 18 0C            JR SALIDA
 35+  BE15              SET_P2:
 36+  BE15 F5               PUSH AF
 37+  BE16 3E 02            LD A, JUGADOR2
 38+  BE18 32 0C 80         LD (JUGADOR_ACTUAL), A
 39+  BE1B 3E 03            LD A, COLOR_JUGADOR2
 40+  BE1D 32 0D 80         LD (COLOR_JUGADOR_ACTUAL), A
 41+  BE20 F1               POP AF
 42+  BE21              SALIDA:
 43+  BE21 C9               RET
 44+  BE22
 45+  BE22              ; RESETEA LA CONDICION DEL TABLERO ACTUAL A TODO CEROS EN LA VARIABLE.
 46+  BE22              LF_BOARD_RESET:
 47+  BE22 AF               XOR A                   ; A = 0
 48+  BE23 32 0F 80         LD (LEFT_COUNTER), A    ; Reseteamos contador izquierdo
 49+  BE26 32 10 80         LD (RIGHT_COUNTER), A   ; Reseteamos contador derecho
 50+  BE29 32 0E 80         LD (GANADOR), A         ; Borramos el ganador anterior
 51+  BE2C
 52+  BE2C 06 07            LD B, 7
 53+  BE2E DD 21 19 80      LD IX, TABLERO_ACTUAL
 54+  BE32 AF               XOR A
 55+  BE33              BR_BUCLE_EXTERNO:
 56+  BE33 C5               PUSH BC
 57+  BE34 06 06            LD B, 6
 58+  BE36              BR_BUCLE_INTERNO:
 59+  BE36 DD 77 00         LD (IX), A
 60+  BE39 DD 23            INC IX
 61+  BE3B 10 F9            DJNZ BR_BUCLE_INTERNO
 62+  BE3D C1               POP BC
 63+  BE3E DD 23            INC IX
 64+  BE40 10 F1            DJNZ BR_BUCLE_EXTERNO
 65+  BE42 C9               RET
 66+  BE43
 67+  BE43              ; JUGADA_DESPLAZAMIENTO - Administra desplazamiento tras Q/W
 68+  BE43              LF_JUGADA_DESPLAZAMIENTO:
 69+  BE43 FE 57            CP 'W'
 69+  BE45 CC B6 BD       CALL Z, GC_RIGHT              ; Desplaza ficha a la derecha
 70+  BE48 FE 4F            CP 'O'
 70+  BE4A CC B6 BD       CALL Z, GC_RIGHT              ; Desplaza ficha a la derecha
 71+  BE4D FE 51            CP 'Q'
 71+  BE4F CC A5 BD       CALL Z, GC_LEFT               ; Desplaza ficha a la izquierda
 72+  BE52 FE 49            CP 'I'
 72+  BE54 CC A5 BD       CALL Z, GC_LEFT               ; Desplaza ficha a la izquierda
 73+  BE57 3E FF            LD A, $FF
 74+  BE59 C9               RET
# file closed: C:\Users\luisx\OneDrive - UFV\curso2\AOC\ejerYpruebas\L34-Parte1\logic_flow.asm
 19   BE5A                  INCLUDE "logic_checks.asm"   ; Comprobaciones de victoria y jugadas
# file opened: C:\Users\luisx\OneDrive - UFV\curso2\AOC\ejerYpruebas\L34-Parte1\logic_checks.asm
  1+  BE5A              ; Lógica de comprobaciones del juego (Conecta 4)
  2+  BE5A              ; Constantes y configuración:
  3+  BE5A              ULTIMA_FICHA_COLUMNA EQU $C001 ; Byte (0-6) con la columna de la última ficha jugada
  4+  BE5A              ULTIMA_FICHA_FILA EQU $C002    ; Byte (0-5) con la fila de la última ficha jugada
  5+  BE5A              TABLERO_ANCHO EQU 7
  6+  BE5A              TABLERO_ALTO EQU 6
  7+  BE5A              ESTADO_TABLERO EQU $D000      ; dirección base en memoria donde se almacena el tablero (fila-major)
  8+  BE5A              ; Nota: se espera que otras rutinas escriban la columna/fila en las direcciones ULTIMA_FICHA_* antes de llamar
  9+  BE5A
 10+  BE5A              ; Comrpueba el resultado del juego tras una jugada, necesita modificaciones
 11+  BE5A              LC_COMPROBAR_RESULTADO:
 12+  BE5A CD 7F BE         CALL LC_COMPROBAR_VICTORIA_JUGADOR
 13+  BE5D FE 00            CP 0
 13+  BE5F C8             RET Z ; RET SI ALGUIEN GANÓ, A = 0
 14+  BE60 CD 6A BE         CALL LC_COMPROBAR_TABLERO_LLENO
 15+  BE63 FE 20            CP 32
 15+  BE65 C8             RET Z ; RET SI NADIE GANÓ Y SE LLENÓ EL TABLERO, A = 32
 16+  BE66 3E 80            LD A, 128
 16+  BE68 B7             OR A ; OR A PARA MODIFICAR LOS FLAGS
 17+  BE69 C9               RET ; RET SI NADIE GANÓ Y NO SE LLENÓ EL TABLERO, A = 128
 18+  BE6A
 19+  BE6A              ; Rutina para comprobar si el tablero se ha llenado
 20+  BE6A              LC_COMPROBAR_TABLERO_LLENO:
 21+  BE6A DD 21 19 80      LD IX, TABLERO_ACTUAL
 22+  BE6E 06 07            LD B, 7 ; Contador de las 7 columnas
 23+  BE70 11 07 00         LD DE, COLUMN_BOARD_SIZE   ; Desplazamiento de 6 en 6 para ir al siguiente slot de la columna
 24+  BE73              CTL_BUCLE:
 25+  BE73 DD 7E 00         LD A, (IX)  ; Carga en A el valor de la celda actual que apunta IX
 26+  BE76 B7               OR A    ; Verifica si hay un hueco vacio
 27+  BE77 C8               RET Z ; RET SIN EMPATE, A = 0, hay hueco
 28+  BE78 DD 19            ADD IX, DE  ; Salta a la siguiente posicion para comprobar ( IX + 6, siguiente fila)
 29+  BE7A 10 F7            DJNZ CTL_BUCLE
 30+  BE7C 3E 20            LD A, 32 ; No encontro huecos
 31+  BE7E C9               RET ; RET CON EMPATE, A = 64
 32+  BE7F
 33+  BE7F              ; Rutina que comprueba si el jugador ha ganado por alguna línea, ya sea vertical, horizontal o diagonal.
 34+  BE7F              LC_COMPROBAR_VICTORIA_JUGADOR:
 35+  BE7F                  ; Comprobamos Horizontal
 36+  BE7F CD A4 BE         CALL LC_COMPROBAR_4_EN_RAYA_HORIZONTAL
 37+  BE82 FE 04            CP 4                         ; Comparamos el resultado con 4
 38+  BE84 30 12            JR NC, VICTORIA_CONFIRMADA   ; Si A >= 4 (No Carry), saltamos a victoria
 39+  BE86
 40+  BE86                  ; Comprobamos Vertical
 41+  BE86 CD DA BE         CALL LC_COMPROBAR_4_EN_RAYA_VERTICAL
 42+  BE89 FE 04            CP 4
 43+  BE8B 30 0B            JR NC, VICTORIA_CONFIRMADA
 44+  BE8D
 45+  BE8D                  ; Comprobamos Diagonales
 46+  BE8D CD 0A BF         CALL LC_COMPROBAR_4_EN_RAYA_DIAGONALES
 47+  BE90 FE 04            CP 4
 48+  BE92 30 04            JR NC, VICTORIA_CONFIRMADA
 49+  BE94
 50+  BE94                  ; SI LLEGAMOS AQUÍ, NADIE GANÓ
 51+  BE94 3E 01            LD A, 1      ; Cargamos 1 (Código de "Sigue jugando")
 52+  BE96 B7               OR A         ; Aseguramos que el flag Z se apague
 53+  BE97 C9               RET          ; Volvemos
 54+  BE98
 55+  BE98              VICTORIA_CONFIRMADA:
 56+  BE98 CD 9C BE         CALL HAY_GANADOR  ; Guarda el ganador y pone A=0
 57+  BE9B C9               RET               ; Devuelve A=0 (Victoria)
 58+  BE9C
 59+  BE9C              ; Guarda en la variable ganador el color del jugador actual
 60+  BE9C              HAY_GANADOR:
 61+  BE9C 3A 0D 80         LD A, (COLOR_JUGADOR_ACTUAL)
 62+  BE9F 32 0E 80         LD (GANADOR), A
 63+  BEA2 AF               XOR A
 64+  BEA3 C9               RET ; RET CON GANADOR, A = 0
 65+  BEA4
 66+  BEA4              ; ############################################################################
 67+  BEA4              ; ############### COMPROBAR 4 EN RAYA EN DISTINTAS DIRECCIONES ###############
 68+  BEA4              ; ############################################################################
 69+  BEA4
 70+  BEA4              ; Comprueba si se ha obtenido 4 en raya por línea horizontal
 71+  BEA4              LC_COMPROBAR_4_EN_RAYA_HORIZONTAL:
 72+  BEA4 E5               PUSH HL
 73+  BEA5 DD 21 19 80      LD IX, TABLERO_ACTUAL
 74+  BEA9 CD 36 C0         CALL U_CALC_TABLERO_POS ; Calcula la direccion de memoria exacta de la ultima ficha puesta en IX
 75+  BEAC 11 F9 FF         LD DE, $FFF9 ; -7 en complemento a 2 para desplazarse por columnas hacia la izquierda en IX
 76+  BEAF 0E 00            LD C, 0
 77+  BEB1              CONTAR_IZQUIERDA:
 78+  BEB1 3A 0C 80         LD A, (JUGADOR_ACTUAL) ; Se guarda el color del jugador actual
 79+  BEB4 47               LD B, A ; Se guarda en B
 80+  BEB5 DD 19            ADD IX, DE ; Desplazamos IX una columna a la izquierda
 81+  BEB7 DD 7E 00         LD A, (IX) ; Guardamos el contenido de IX en A
 82+  BEBA B8               CP B ; Comparamos con B
 83+  BEBB CC AC BF         CALL Z, INC_CNT_IZQ ; Si son iguales, debemos incrementar el contador de consecutivos que hay hacia la 'izquierda' de la ficha
 84+  BEBE 28 F1            JR Z, CONTAR_IZQUIERDA ; Si fueron iguales, podemos continuar contando más fichas en esta dirección
 85+  BEC0
 86+  BEC0 E1               POP HL
 87+  BEC1 CD 36 C0         CALL U_CALC_TABLERO_POS ; Volvemos al IX de la ficha que fue soltada en este turno
 88+  BEC4 11 07 00         LD DE, COLUMN_BOARD_SIZE ; Cargamos 7 en DE
 89+  BEC7              CONTAR_DERECHA: ; Mismo concepto que CONTAR_IZQUIERDA, pero desplaza en columnas hacia la derecha en vez de la izquierda
 90+  BEC7 3A 0C 80         LD A, (JUGADOR_ACTUAL)
 91+  BECA 47               LD B, A
 92+  BECB DD 19            ADD IX, DE
 93+  BECD DD 7E 00         LD A, (IX)
 94+  BED0 B8               CP B
 95+  BED1 CC B6 BF         CALL Z, INC_CNT_DER
 96+  BED4 28 F1            JR Z, CONTAR_DERECHA
 97+  BED6 CD 95 BF         CALL CONTAR_TOTALES ; Cuenta el total de consecutivos a la izquierda y derecha de la ficha soltada.
 98+  BED9 C9               RET
 99+  BEDA
100+  BEDA              ; COMPROBACION DE VICTORIA EN VERTICAL
101+  BEDA              LC_COMPROBAR_4_EN_RAYA_VERTICAL: ; Mismo concepto que comprobación en horizontal, pero puede hacer DEC IX e INC IX directamente
102+  BEDA E5               PUSH HL
103+  BEDB DD 21 19 80      LD IX, TABLERO_ACTUAL
104+  BEDF CD 36 C0         CALL U_CALC_TABLERO_POS
105+  BEE2 0E 00            LD C, 0
106+  BEE4              CONTAR_ARRIBA:
107+  BEE4 3A 0C 80         LD A, (JUGADOR_ACTUAL)
108+  BEE7 47               LD B, A
109+  BEE8 DD 2B            DEC IX
110+  BEEA DD 7E 00         LD A, (IX)
111+  BEED B8               CP B
112+  BEEE CC AC BF         CALL Z, INC_CNT_IZQ
113+  BEF1 28 F1            JR Z, CONTAR_ARRIBA
114+  BEF3
115+  BEF3 E1               POP HL
116+  BEF4 CD 36 C0         CALL U_CALC_TABLERO_POS
117+  BEF7              CONTAR_ABAJO:
118+  BEF7 3A 0C 80         LD A, (JUGADOR_ACTUAL)
119+  BEFA 47               LD B, A
120+  BEFB DD 23            INC IX
121+  BEFD DD 7E 00         LD A, (IX)
122+  BF00 B8               CP B
123+  BF01 CC B6 BF         CALL Z, INC_CNT_DER
124+  BF04 28 F1            JR Z, CONTAR_ABAJO
125+  BF06 CD 95 BF         CALL CONTAR_TOTALES
126+  BF09 C9               RET
127+  BF0A
128+  BF0A              ; COMPROBACION DE VICTORIA EN DIAGONALES
129+  BF0A              LC_COMPROBAR_4_EN_RAYA_DIAGONALES:
130+  BF0A DD 21 19 80      LD IX, TABLERO_ACTUAL
131+  BF0E CD 36 C0         CALL U_CALC_TABLERO_POS
132+  BF11                  ;LD C, 0
133+  BF11 E5               PUSH HL
134+  BF12              CONTAR_UPPER_LEFT:
135+  BF12 7C               LD A, H
136+  BF13 B7               OR A
137+  BF14 28 18            JR Z, FIN_UPPER_LEFT
138+  BF16 7D               LD A, L
139+  BF17 B7               OR A            ; CP 0
140+  BF18 28 14            JR Z, FIN_UPPER_LEFT
141+  BF1A
142+  BF1A 25               DEC H
142+  BF1B 2D             DEC L ; Movemos IX a la posición diagonal superior izquierda
143+  BF1C CD 36 C0         CALL U_CALC_TABLERO_POS ; Aqui B se corrompe con el numero de columna
144+  BF1F                  ; DESPLAZAMIENTO DE IX
145+  BF1F 3A 0C 80         LD A, (JUGADOR_ACTUAL)  ; Se vuelve a leer quien esta jugando
146+  BF22 47               LD B, A ; Se restaura el valor correcto de B
147+  BF23 DD 7E 00         LD A, (IX)
148+  BF26 B8               CP B    ; Ahora si se comparan los colores
149+  BF27 20 05            JR NZ, FIN_UPPER_LEFT
150+  BF29 CD AC BF         CALL INC_CNT_IZQ
151+  BF2C 18 E4            JR CONTAR_UPPER_LEFT
152+  BF2E              FIN_UPPER_LEFT:
153+  BF2E E1               POP HL
154+  BF2F E5               PUSH HL
155+  BF30              CONTAR_LOWER_RIGHT:
156+  BF30 7C               LD A, H
157+  BF31 FE 05            CP 5
158+  BF33 28 19            JR Z, FIN_LOWER_RIGHT
159+  BF35 7D               LD A, L
160+  BF36 FE 06            CP 6
161+  BF38 28 14            JR Z, FIN_LOWER_RIGHT
162+  BF3A
163+  BF3A 24               INC H
163+  BF3B 2C             INC L ; Movemos IX a la posición diagonal inferior derecha
164+  BF3C CD 36 C0         CALL U_CALC_TABLERO_POS
165+  BF3F                  ; DESPLAZAMIENTO DE IX
166+  BF3F 3A 0C 80         LD A, (JUGADOR_ACTUAL)
167+  BF42 47               LD B, A
168+  BF43 DD 7E 00         LD A, (IX)
169+  BF46 B8               CP B
170+  BF47 20 05            JR NZ, FIN_LOWER_RIGHT
171+  BF49 CC B6 BF         CALL Z, INC_CNT_DER
172+  BF4C 18 E2            JR CONTAR_LOWER_RIGHT
173+  BF4E              FIN_LOWER_RIGHT:
174+  BF4E E1               POP HL
175+  BF4F CD 95 BF         CALL CONTAR_TOTALES ; Contamos totales en esa diagonal Superior Izquierda + Inferior Derecha
176+  BF52 C0               RET NZ ; RET aquí si ya se consiguió que los totales superaran 3.
177+  BF53 E5               PUSH HL
178+  BF54              CONTAR_UPPER_RIGHT:
179+  BF54                  ; Si Fila (H) = 0 o Columna (L) = 6, no podemos subir a la derecha
180+  BF54 7C               LD A, H
181+  BF55 B7               OR A
182+  BF56 28 19            JR Z, FIN_UPPER_RIGHT
183+  BF58 7D               LD A, L
184+  BF59 FE 06            CP 6
185+  BF5B 28 14            JR Z, FIN_UPPER_RIGHT
186+  BF5D
187+  BF5D 25               DEC H
187+  BF5E 2C             INC L
188+  BF5F CD 36 C0         CALL U_CALC_TABLERO_POS
189+  BF62                  ; MOVIMIENTO
190+  BF62 3A 0C 80         LD A, (JUGADOR_ACTUAL)
191+  BF65 47               LD B, A
192+  BF66                  ; COMPROBACIÓN
193+  BF66 DD 7E 00         LD A, (IX)
194+  BF69 B8               CP B
195+  BF6A 20 05            JR NZ, FIN_UPPER_RIGHT
196+  BF6C
197+  BF6C CD B6 BF         CALL INC_CNT_DER ; Usamos el contador "derecho" para una mitad de esta diagonal
198+  BF6F 18 E3            JR CONTAR_UPPER_RIGHT
199+  BF71              FIN_UPPER_RIGHT:
200+  BF71
201+  BF71 E1               POP HL ; Recuperamos origen
202+  BF72 E5               PUSH HL ; Guardamos para la ultima dirección
203+  BF73
204+  BF73              CONTAR_LOWER_LEFT:
205+  BF73                  ; Si Fila (H) = 5 o Columna (L) = 0, no podemos bajar a la izquierda
206+  BF73 7C               LD A, H
207+  BF74 FE 05            CP 5
208+  BF76 28 18            JR Z, FIN_LOWER_LEFT
209+  BF78 7D               LD A, L
210+  BF79 B7               OR A
211+  BF7A 28 14            JR Z, FIN_LOWER_LEFT
212+  BF7C
213+  BF7C 24               INC H
213+  BF7D 2D             DEC L
214+  BF7E CD 36 C0         CALL U_CALC_TABLERO_POS
215+  BF81                  ; MOVIMIENTO
216+  BF81 3A 0C 80         LD A, (JUGADOR_ACTUAL)
217+  BF84 47               LD B, A
218+  BF85                  ; COMPROBACIÓN
219+  BF85 DD 7E 00         LD A, (IX)
220+  BF88 B8               CP B
221+  BF89 20 05            JR NZ, FIN_LOWER_LEFT
222+  BF8B
223+  BF8B CD AC BF         CALL INC_CNT_IZQ ; Usamos el contador "izquierdo" para la otra mitad
224+  BF8E 18 E3            JR CONTAR_LOWER_LEFT
225+  BF90              FIN_LOWER_LEFT:
226+  BF90
227+  BF90 E1               POP HL
228+  BF91 CD 95 BF         CALL CONTAR_TOTALES
229+  BF94 C9               RET
230+  BF95
231+  BF95              ; Contar total de consecutivos a partir de un punto
232+  BF95              CONTAR_TOTALES:
233+  BF95 3A 0F 80         LD A, (LEFT_COUNTER) ; Guardamos el contador lateral 1
234+  BF98 4F               LD C, A ; Lo guardamos en C
235+  BF99 3A 10 80         LD A, (RIGHT_COUNTER) ; Guardamos el contador lateral 2
236+  BF9C 81               ADD A, C ; Le agregamos C - A = Left_Counter + Right_Counter
237+  BF9D 3C               INC A ; A = Left_Counter + Right_Counter + 1
238+  BF9E                  ; Ficha soltada + consecutivas a un lado + consecutivas al opuesto
239+  BF9E FE 04            CP 4 ; Comparamos con 4
240+  BFA0 30 08            JR NC, SALIDA_CONTAR_TOTALES ; Si fue 4 o más, el flag carry estará en 0 = NC
241+  BFA2 3E 00            LD A, 0 ; Guardar A = 0
242+  BFA4 32 0F 80         LD (LEFT_COUNTER), A ; Reiniciamos los contadores
243+  BFA7 32 10 80         LD (RIGHT_COUNTER), A
244+  BFAA              SALIDA_CONTAR_TOTALES:
245+  BFAA B7               OR A ; No modifica A pero activa flags según el caso
246+  BFAB C9               RET ; RET CON EL VALOR DE GANADOR (A != 0) o NO
247+  BFAC
248+  BFAC              ; Cuenta consecutivos a un lado de la ficha soltada
249+  BFAC              INC_CNT_IZQ:
250+  BFAC F5               PUSH AF
251+  BFAD 3A 0F 80         LD A, (LEFT_COUNTER)
252+  BFB0 3C               INC A ; Incrementa el contador por 1
253+  BFB1 32 0F 80         LD (LEFT_COUNTER), A ; Guarda el nuevo valor en la variable
254+  BFB4 F1               POP AF
255+  BFB5 C9               RET
256+  BFB6
257+  BFB6              ; Cuenta consecutivos al lado opuesto de la rutina superior
258+  BFB6              INC_CNT_DER:
259+  BFB6 F5               PUSH AF
260+  BFB7 3A 10 80         LD A, (RIGHT_COUNTER)
261+  BFBA 3C               INC A ; Incrementa el contador por 1
262+  BFBB 32 10 80         LD (RIGHT_COUNTER), A ; Guarda el nuevo valor en la variable
263+  BFBE F1               POP AF
264+  BFBF C9               RET
265+  BFC0
266+  BFC0
267+  BFC0              LC_SLOT_POINTER:
268+  BFC0              ; SLOT_POINTER - Calcula dirección de videoram a partir de fila/columna del tablero, no de la pantalla
269+  BFC0              ; H = fila del tablero, L = columna del tablero, HL = dirección de videoram
270+  BFC0                  ; PREREQUISITO: HABER SELECCIONADO UNA FILA Y UNA COLUMNA (H Y L) SOBRE LA QUE SE QUIERE OBTENER UNA DIRECCIÓN VIDEORAM
271+  BFC0                  ; H = FILA
272+  BFC0                  ; L = COLUMNA
273+  BFC0                  ; HL = DIRECCIÓN DE LA VIDEORAM
274+  BFC0
275+  BFC0 F5               PUSH AF
276+  BFC1 7D               LD A, L
277+  BFC2 85               ADD L
277+  BFC3 85             ADD L
277+  BFC4 C6 05          ADD 5
278+  BFC6 6F               LD L, A
279+  BFC7 7C               LD A, H ; 0 0 0 H4 H3 H2 H1 H0
280+  BFC8 84               ADD H
280+  BFC9 84             ADD H
280+  BFCA C6 02          ADD 2
281+  BFCC 67               LD H, A
282+  BFCD CB 27            SLA A
282+  BFCF CB 27          SLA A
282+  BFD1 CB 27          SLA A
282+  BFD3 CB 27          SLA A
282+  BFD5 CB 27          SLA A ; H2 H1 H0 0 0 0 0 0
283+  BFD7 B5               OR L ; H2 H1 H0 L4 L3 L2 L1 L0
284+  BFD8 6F               LD L, A
285+  BFD9 7C               LD A, H ; 0 0 0 H4 H3 H2 H1 H0
286+  BFDA CB 2F            SRA A
286+  BFDC CB 2F          SRA A
286+  BFDE CB 2F          SRA A; 0 0 0 0 0 0 H4 H3
287+  BFE0 F6 58            OR $58 ; 0 1 0 1 1 0 H4 H3
288+  BFE2 67               LD H, A
289+  BFE3                  ; HL = 0 1 0 1 1 0 H4 H3 H2 H1 H0 L4 L3 L2 L1 L0
290+  BFE3 F1               POP AF
291+  BFE4 C9               RET
292+  BFE5
293+  BFE5              LC_VALIDPLAY:
294+  BFE5                  ; Comprueba si la jugada solicitada por el jugador es válida:
295+  BFE5                  ;   - Recibe en HL el valor actual de la ficha, no el valor al que se podría desplazar, será 0,L
296+  BFE5                  ;   - Para Q/W y O/P (izquierda/derecha) se comprueba que la celda objetivo no esté ocupada
297+  BFE5                  ;   - Para F se considerará válida si la columna no está ocupada en la posición del cursor
298+  BFE5                  ;   - Para ENTER se considerará válida si la columna actual no está llena
299+  BFE5 7A               LD A, D
300+  BFE6 FE 51            CP 'Q'
300+  BFE8 28 18          JR Z, VALIDLEFT
301+  BFEA FE 49            CP 'I'
301+  BFEC 28 14          JR Z, VALIDLEFT
302+  BFEE FE 57            CP 'W'
302+  BFF0 28 1F          JR Z, VALIDRIGHT
303+  BFF2 FE 4F            CP 'O'
303+  BFF4 28 1B          JR Z, VALIDRIGHT
304+  BFF6 FE 45            CP 'E'
304+  BFF8 28 26          JR Z, VALIDENTER
305+  BFFA FE 50            CP 'P'
305+  BFFC 28 22          JR Z, VALIDENTER
306+  BFFE FE 46            CP 'F'
306+  C000 28 2F          JR Z, VALID ; F = Fin de la partida, siempre es válido
307+  C002
308+  C002              ; Comprueba si fue una pulsación váida para mover la ficha a la izquierda
309+  C002              VALIDLEFT:
310+  C002 E5               PUSH HL
311+  C003 21 00 00         LD HL, $00
312+  C006 CD C0 BF         CALL LC_SLOT_POINTER
313+  C009 7E               LD A, (HL)
314+  C00A E1               POP HL
315+  C00B FE 80            CP BLINK ; si el atributo de color en HL es menor que blink (que lo será si no está sobre la posición más izquierda del tablero)
316+  C00D 38 22            JR C, VALID ; se hará una activación del flag C, por lo que será válida la pulsación
317+  C00F 18 1D            JR NONVALID
318+  C011
319+  C011              ; Comprueba si fue una pulsación válida para mover la ficha a la derecha
320+  C011              VALIDRIGHT:
321+  C011 E5               PUSH HL
322+  C012 21 06 00         LD HL, $06 ; mismo concepto que validleft, pero la comparación se hace con el contenido de la fila 0, columna 6 en vez de la 0,0
323+  C015 CD C0 BF         CALL LC_SLOT_POINTER
324+  C018 7E               LD A, (HL)
325+  C019 E1               POP HL
326+  C01A FE 80            CP BLINK
327+  C01C 38 13            JR C, VALID
328+  C01E 18 0E            JR NONVALID
329+  C020              VALIDENTER: ; mismo concepto que validleft y right, pero la comparación se hace con la ficha inmediatamente inferior
330+  C020 D5               PUSH DE
330+  C021 E5             PUSH HL
331+  C022 CD 36 C0         CALL U_CALC_TABLERO_POS
332+  C025 DD 7E 00         LD A, (IX)
333+  C028 E1               POP HL
333+  C029 D1             POP DE
334+  C02A FE 00            CP 0
334+  C02C 28 03          JR Z, VALID ; si aquí no saltó a valid, lee directamente la siguiente instrucción,
335+  C02E                                    ; que serán las correspondientes a NONVALID
336+  C02E
337+  C02E              NONVALID:
338+  C02E 3E 01            LD A, 1
339+  C030 C9               RET
340+  C031              VALID:
341+  C031 3E 02            LD A, 2
342+  C033 C9               RET
343+  C034
344+  C034
# file closed: C:\Users\luisx\OneDrive - UFV\curso2\AOC\ejerYpruebas\L34-Parte1\logic_checks.asm
 20   C034                  INCLUDE "utilities.asm"      ; Rutinas que no son características de ninguna función particular
# file opened: C:\Users\luisx\OneDrive - UFV\curso2\AOC\ejerYpruebas\L34-Parte1\utilities.asm
  1+  C034 18 FE        UTILITIES: JR UTILITIES
  2+  C036
  3+  C036              U_CALC_TABLERO_POS:
  4+  C036                  ; Calcula IX = TABLERO_ACTUAL + (L * 7) + H
  5+  C036                  ; Donde H = row, L = columna en coordenadas originales de tablero
  6+  C036
  7+  C036 7D               LD A, L                    ; Guarda columna (L)
  8+  C037 47               LD B, A                    ; guarda L en B
  9+  C038 87               ADD A, A                   ; A = L * 2
 10+  C039 87               ADD A, A                   ; A = L * 4
 11+  C03A 87               ADD A, A                   ; A = L * 8
 12+  C03B 90               SUB B                      ; A = L * 7 (ya que 8L - L = 7L)
 13+  C03C 84               ADD A, H                   ; A = (L * 7) + H
 14+  C03D
 15+  C03D DD 21 19 80      LD IX, TABLERO_ACTUAL      ; Dirección de (0,0)
 16+  C041 16 00            LD D, 0
 17+  C043 5F               LD E, A                    ; DE = desplazamiento
 18+  C044 DD 19            ADD IX, DE                 ; IX apunta a tablero actual (h,l)
 19+  C046
 20+  C046 C9               RET
 21+  C047
 22+  C047              ; Rutina de espera
 23+  C047              U_ESPERAR:
 24+  C047 C5               PUSH BC
 25+  C048 01 7B 2C         LD BC, 11387
 26+  C04B
 27+  C04B              ESPERAR_LOOP:
 28+  C04B 0B               DEC BC                     ; 6C
 29+  C04C 78               LD A, B                    ; 4C
 30+  C04D B1               OR C                       ; 4C
 31+  C04E 00               NOP                        ; 4C
 32+  C04F 00               NOP                        ; 4C
 33+  C050 00               NOP                        ; 4C
 34+  C051 20 F8            JR NZ, ESPERAR_LOOP        ; 12C
 35+  C053
 36+  C053 C1               POP BC
 37+  C054 C9               RET
# file closed: C:\Users\luisx\OneDrive - UFV\curso2\AOC\ejerYpruebas\L34-Parte1\utilities.asm
 21   C055
 22   C055              ; INICIO DEL FLUJO DEL PROGRAMA FUNCIONAL
 23   C055              ; Pantalla de bienvenida y gestión de entrada inicial
 24   C055              INICIO:
 25   C055 CD C0 BB         CALL GB_BIENVENIDA           ; Dibuja pantalla de bienvenida
 26   C058 CD 51 80         CALL K_SON                   ; Lee teclado (S/N)
 27   C05B 7A               LD A, D
 28   C05C 32 BE 85         LD (CHAR_CARACTER), A        ; Guarda la tecla pulsada
 29   C05F 3E 06            LD A, COLOR_TEXTO_AMARILLO
 30   C061 CD 25 BC         CALL GB_PRINT_CHAR_SON       ; Imprime la tecla pulsada
 31   C064 3A BE 85         LD A, (CHAR_CARACTER)
 32   C067 FE 53            CP 'S'
 33   C069 CC 9E C0         CALL Z, LOGICA_JUEGO         ; Si se pulsó 'S', comienza la lógica del juego
 34   C06C FE 4E            CP 'N'
 35   C06E CC 71 C0         CALL Z, ADIOS                ; Si se pulsó 'N', muestra pantalla de despedida
 36   C071
 37   C071              ; Pantalla de despedida
 38   C071              ADIOS:
 39   C071 CD 31 BC         CALL GB_ADIOS                ; Dibuja pantalla de adiós
 40   C074              FINAL: ; Bucle final (espera y halt)
 41   C074 06 0A            LD B, 10
 42   C076 CD 47 C0         CALL U_ESPERAR
 43   C079 10 F9            DJNZ FINAL
 44   C07B 76               HALT
 45   C07C
 46   C07C              ; Pantalla de fin de partida y opción de reinicio
 47   C07C              FIN_NEXT:
 48   C07C CD 58 BC         CALL GB_FIN_NEXT             ; Dibuja pantalla de fin y pregunta S/N
 49   C07F CD 51 80         CALL K_SON                   ; Lee teclado (S/N)
 50   C082 7A               LD A, D
 51   C083 FE 53            CP 'S'
 52   C085 CC 9E C0         CALL Z, LOGICA_JUEGO         ; Si se pulsó 'S', inicia nuevo juego
 53   C088 FE 4E            CP 'N'
 54   C08A CC 71 C0         CALL Z, ADIOS                ; Si se pulsó 'N', muestra pantalla de despedida
 55   C08D
 56   C08D              EMPATE:
 57   C08D CD 64 BC         CALL GB_EMPATE
 58   C090 CD 51 80         CALL K_SON                   ; Lee teclado (S/N)
 59   C093 7A               LD A, D
 60   C094 FE 53            CP 'S'
 61   C096 CC 9E C0         CALL Z, LOGICA_JUEGO         ; Si se pulsó 'S', inicia nuevo juego
 62   C099 FE 4E            CP 'N'
 63   C09B CC 71 C0         CALL Z, ADIOS                ; Si se pulsó 'N', muestra pantalla de despedida
 64   C09E              ; Lógica principal del juego
 65   C09E              LOGICA_JUEGO:
 66   C09E CD B7 BC         CALL GB_PTLLA_INICIO_DE_JUEGO ; Dibuja pantalla de inicio de juego
 67   C0A1 CD F2 BD         CALL LF_INICIALIZACION        ; Inicializa condiciones del juego
 68   C0A4              BUCLE_JUEGO:
 69   C0A4 CD FC BD         CALL LF_SWITCH_JUGADOR        ; Cambia de jugador
 70   C0A7              GESTIONAR_JUGADA:
 71   C0A7 CD 67 BD         CALL GC_COLOR_JUGADOR_ACTUAL  ; Muestra el jugador actual en pantalla (HL = $5845)
 72   C0AA              JUGADA:
 73   C0AA CD 74 80         CALL K_LR_E_F             ; Lee entrada (Q/W/O/P/ENTER/F)
 74   C0AD 7A               LD A, D
 75   C0AE F5               PUSH AF
 76   C0AF CD E5 BF         CALL LC_VALIDPLAY             ; Comprueba si la jugada es válida
 77   C0B2 FE 01            CP 1
 78   C0B4 28 F4            JR Z, JUGADA                  ; Si no fue válida, espera nueva jugada
 79   C0B6 F1               POP AF
 80   C0B7 FE 51            CP 'Q'
 80   C0B9 CC 43 BE       CALL Z, LF_JUGADA_DESPLAZAMIENTO ; Desplaza ficha a la derecha
 81   C0BC FE 57            CP 'W'
 81   C0BE CC 43 BE      CALL Z, LF_JUGADA_DESPLAZAMIENTO ; Desplaza ficha a la izquierda
 82   C0C1 FE 49            CP 'I'
 82   C0C3 CC 43 BE       CALL Z, LF_JUGADA_DESPLAZAMIENTO ; Desplaza ficha a la derecha
 83   C0C6 FE 4F            CP 'O'
 83   C0C8 CC 43 BE      CALL Z, LF_JUGADA_DESPLAZAMIENTO ; Desplaza ficha a la izquierda
 84   C0CB FE FF            CP $FF
 84   C0CD 28 DB          JR Z, JUGADA
 85   C0CF FE 45            CP 'E'
 85   C0D1 CC E0 C0       CALL Z, PROCESAR_JUGADA_FINAL
 86   C0D4 FE 50            CP 'P'
 86   C0D6 CC E0 C0       CALL Z, PROCESAR_JUGADA_FINAL             ; Ejecuta acción de soltar ficha
 87   C0D9
 88   C0D9 FE 46            CP 'F'
 88   C0DB CC 7C C0       CALL Z, FIN_NEXT              ; Termina partida
 89   C0DE
 90   C0DE 18 CA            JR JUGADA
 91   C0E0              PROCESAR_JUGADA_FINAL:
 92   C0E0 CD C7 BD         CALL GC_ENTER             ; La ficha cae
 93   C0E3
 94   C0E3                  ; AQUI CONECTAMOS CON LA LOGICA
 95   C0E3 CD 5A BE         CALL LC_COMPROBAR_RESULTADO
 96   C0E6 28 94            JR Z, FIN_NEXT            ; ¡SI (A=0), HA GANADO, SE VA A LA PANTALLA
 97   C0E8
 98   C0E8                  ; SI NO GANASTE, COMPROBAR EMPATE O SEGUIR (MIRAMOS EL FLAG C YA QUE SI SE ACTIVA ES EMPATE(EL 1 DE EMPATE ES MENOR QUE 64))
 99   C0E8                  ; SI NO SE ACTIVA EL FLAG C = CONTINUAR PARTIDA (128 = CONTINUAR PARTIDA Y ES > 64)
100   C0E8 FE 40            CP 64   ; COMPRUEBA EMPATE O SEGUIR JUEGO (NUMERO RANDOM ENTRE EL 1(EMPATE) Y 128(SEGUIR JUGANDO))
101   C0EA 38 A1            JR C, EMPATE
102   C0EC 18 B6            JR BUCLE_JUEGO
103   C0EE              ; Comprobación de fin de juego
104   C0EE              COMPROBAR_FIN_JUEGO:
105   C0EE CD 5A BE         CALL LC_COMPROBAR_RESULTADO        ; Comprueba si hay victoria o empate
106   C0F1 28 89            JR Z, FIN_NEXT ; HAY GANADOR
107   C0F3 FE 40            CP 64
108   C0F5 38 96            JR C, EMPATE ; HUBO EMPATE
109   C0F7 18 AB            JR BUCLE_JUEGO                ; Si no hay fin, sigue el juego
# file closed: C:\Users\luisx\OneDrive - UFV\curso2\AOC\ejerYpruebas\L34-Parte1\main.asm
